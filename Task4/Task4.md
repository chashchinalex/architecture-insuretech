# Task4 — Проектирование продажи ОСАГО (InsureTech)

## Цели
- Показ предложений по ОСАГО **по мере поступления** от страховых (streaming UI).
- Максимум ожидания ответа от каждой страховой — **60 секунд**.
- Поддержка **2 500 одновременных пользователей** в пике.
- Не менять функциональную декомпозицию доменных сервисов; добавить **osago-aggregator** как интеграционный.

---

## Ключевые решения

### 1) osago-aggregator — обязанности и хранилище
**Функции:**
- Принимать события о новых заявках ОСАГО, **фан-аут** в страховые: `POST /applications`, затем опрос `GET /quotes/{id}` до 60с.
- Публиковать **частичные результаты** по мере поступления (события «quote updated/ready»).

**Хранилище:**
- Требуется **свое state‑хранилище** для корреляции заявок и статусов интеграций:
  - `Redis/Valkey` (in‑memory, TTL 2–6 часов) — *in‑flight* состояние, дедупликация, rate‑limit счётчики.
  - (Опционально) `PostgreSQL` — аудиторный лог/ретеншн для расследований (не обязателен для SLA 60с).
- Причины: идемпотентность, повтор доставки, ретраи, перезапуск подов (стейт не должен теряться).

### 2) Контракты и API
**Интеграция core-app ↔ osago-aggregator:** *Event Streaming (Kafka/Redpanda)*
- `osago.requests.v1` — событие от `core-app`: новая заявка на ОСАГО (ключ: `request_id`).
- `osago.quotes.v1` — событие от `osago-aggregator`: частичный/финальный ответ от конкретной страховой (ключ: `request_id:insurer_id`).
- `osago.errors.v1` — ошибки интеграции, таймауты, отказоустойчивость.

`core-app` ведёт **read‑model** «витрина предложений» по `request_id`, обновляет UI по мере прихода сообщений.

**Outbox:**
- В `core-app` — **Transactional Outbox** для публикации `osago.requests.v1` синхронно с созданием заявки в БД (список водителя/ТС).
- В `osago-aggregator` — публикация `osago.quotes.v1` идемпотентно (можно без транзакций Kafka, достаточно ключей и UPSERT у потребителя).

**API osago-aggregator (внешне не нужен)**: core не вызывает его REST; общение идёт через события. Для отладки можно оставить `/health` и `/metrics`.

### 3) API core-app для веб-клиента
- `POST /api/osago/requests` → создаёт заявку, возвращает `request_id`.
- **SSE** (Server‑Sent Events): `GET /api/osago/requests/{request_id}/stream`
  - сервер отправляет **поток событий**: частичные котировки по мере поступления, «heartbeat» и финальное «done/timeout» через 60с на страховщика.
- Fallback: `GET /api/osago/requests/{request_id}/quotes` — для восстановления страницы/рефреша.

Выбор SSE (а не WebSocket): однонаправленный стрим «сервер→клиент», простая масштабируемость, работает через CDN/прокси без специальных настроек.

### 4) Паттерны отказоустойчивости
- **Rate Limiting**:
  - входной (B2C): защита от злоупотреблений;
  - исходящий (в osago-aggregator): per‑insurer квоты/лимиты и burst‑буферы.
- **Circuit Breaker** (osago-aggregator→страховые): открывается при ошибках/таймаутах, шорт‑серкуит до next probe.
- **Retry**: экспоненциальный backoff + jitter на `POST` (создать заявку), ограниченный ретрай на `GET` (опрос статуса).
- **Timeout**: 60с per insurer hard‑deadline; короткие таймауты сокетов (e.g. 3–5с) и общий **deadline** запроса.

### 5) Масштабирование и конкуренция
- `osago-aggregator` горизонтально масштабируется; очереди/топики обеспечивают backpressure.
- Пул/вентиль «per‑insurer concurrency» (например, 5–20 одновременных опросов на страховщика).
- `core-app` статeless для SSE (sticky‑sessions через `request_id` необязателен; можно держать SSE в каждом поде, источником данных служит локальная проекция).

---

## Потоки данных

1) Клиент → `core-app`: создаёт заявку (`request_id`). Core в транзакции фиксирует в БД и через **Outbox** публикует `osago.requests.v1`.
2) `osago-aggregator` получает событие, создаёт заявки во всех страховых (с учётом rate‑limit/circuit‑breaker) и начинает опрос `GET /quotes/{id}` **параллельно**.
3) По результату каждого страховщика публикует `osago.quotes.v1` (partial). Отдельно фиксирует таймаут/ошибки в `osago.errors.v1`.
4) `core-app` обновляет **витрину котировок** по `request_id`. Клиент получает новые элементы через **SSE**‑стрим до 60с.

---

## Зависящие от развёртывания моменты (несколько экземпляров сервисов)
- Консьюмер‑группы Kafka обеспечивают распределение нагрузки между подами `osago-aggregator` и `core-app`.
- SSE‑подключения распределяются балансировщиком по подам `core-app`; данные приходят из общей витрины (PostgreSQL/Redis) или локальной материализации (Kafka consumer в каждом поде).
- Rate‑limit счётчики хранятся в Redis (shared) → корректны при горизонтальном масштабировании.

---

## Темы Kafka (новые)
- `osago.requests.v1` (key: `request_id`) — delete, retention ≥ 3 дня.
- `osago.quotes.v1` (key: `request_id:insurer_id`) — delete, retention ≥ 3 дня.
- `osago.errors.v1` (key: `request_id:insurer_id`) — delete, retention ≥ 7 дней.
