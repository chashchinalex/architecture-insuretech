## Задание 3. Переход на Event-Driven архитектуру

### Контекст  
Сервисы **core-app** и **ins-comp-settlement** получают данные о продуктах через REST API сервиса **ins-product-aggregator**.  
Aggregator при каждом запросе:
1. Обращается к пяти страховым компаниям,  
2. Агрегирует ответы,  
3. Возвращает общий список в рамках синхронного вызова.  

**core-app** опрашивает aggregator каждые 15 минут,  
**ins-comp-settlement** — раз в сутки, ночью.  
Кроме того, settlement ночью запрашивает у core-app список всех оформленных страховок.  
Из-за сетевых задержек и ошибок во внешних API возникают таймауты и каскадные сбои.

---

### Проблемы текущей архитектуры
- Зависимость от синхронных вызовов и нестабильных внешних API.  
- Пики нагрузки в одно и то же время (каждые 15 минут и по ночам).  
- Дублирование логики и несогласованность данных между сервисами.  
- Высокая связанность — сбой одного API может повлечь сбой всей цепочки.

---

### Цели перехода
- Разорвать синхронные зависимости.  
- Повысить устойчивость и производительность.  
- Обеспечить своевременную и согласованную доставку данных о продуктах и тарифах.

---

### Решение
**1. Асинхронная модель через события**
- Aggregator по расписанию опрашивает страховые компании.  
- После получения и нормализации данных публикует события в Kafka-топики:
  - `product_updates` — обновления продуктов и тарифов,  
  - `insurance_requests` — новые заявки,  
  - `settlement_status` — статусы расчетов.  
- core-app и ins-comp-settlement подписываются на соответствующие события.

**2. Надежность и отказоустойчивость**
- Настройка **retry/timeout** с экспоненциальным backoff.  
- Изоляция запросов к каждому провайдеру и отдельное отслеживание SLA.  
- Использование **Transactional Outbox** для гарантированной доставки событий:
  - в core-app — при оформлении полисов,  
  - в aggregator — при обновлении данных о продуктах,  
  - в settlement — при формировании реестров и публикации статусов.

---

### Технологии
- **Kafka (Managed)** — основной брокер событий, обеспечивает масштабируемость и повторяемость обработки.  
- **Valkey / Redis** — для кэширования и повторного чтения данных при сбоях.  
- Альтернатива для небольших систем — обмен через JSON-файлы в S3-хранилище.

---

### Ожидаемые результаты
- Уменьшение задержек и пиковых нагрузок.  
- Повышение доступности и устойчивости системы.  
- Снижение времени восстановления (RTO) и потери данных (RPO).  
- Готовность к масштабированию при подключении новых страховых компаний.
